diff --git a/tvm/src/codegen/systemc/codegen_systemc.cc b/tvm/src/codegen/systemc/codegen_systemc.cc
index 668e080..99762e4 100644
--- a/tvm/src/codegen/systemc/codegen_systemc.cc
+++ b/tvm/src/codegen/systemc/codegen_systemc.cc
@@ -1622,7 +1622,7 @@ struct argInfo {
 class InputDirectionCollector : public IRMutator {
  public:
   explicit InputDirectionCollector(
-    const Array<VarExpr>& _input_vars) : input_vars(_input_vars) { }
+    const std::unordered_set<std::string> _input_vars) : input_vars(_input_vars) { }
 
   Stmt Mutate_(const Store* op, const Stmt& s) {
     Stmt stmt = IRMutator::Mutate_(op, s);
@@ -1635,9 +1635,9 @@ class InputDirectionCollector : public IRMutator {
 
   bool checkBuffer(VarExpr var) {
     for (auto& v : input_vars) {
-      if (v.get() == var.get()) {
+      if (v == var.get()->name_hint) {
         HCL_DEBUG_LEVEL(2) << "[ INFO ] Buffer arg "
-            << v.get()->name_hint << " is written...";
+            << v << " is written...";
         return true;
       }
     }
@@ -1646,13 +1646,13 @@ class InputDirectionCollector : public IRMutator {
 
   unordered_map<string, bool>& Analyze(Stmt stmt) {
     for (auto& v : input_vars) {
-      is_arg_written[v.get()->name_hint] = false;
+      is_arg_written[v] = false;
     }
     Stmt s = Mutate(stmt);
     return is_arg_written; 
   }
 
-  const Array<VarExpr>& input_vars;
+  std::unordered_set<std::string> input_vars;
   unordered_map<string, bool> is_arg_written;
 };
 
@@ -1700,9 +1700,10 @@ void CodeGenSystemC::AddFunction(LoweredFunc f,
   this->PrintIndent();
   this->stream << "sc_in< bool > rst;\n";
 
-  Array<VarExpr> input_args;
-  for (auto& v : f->args) {
-      input_args.push_back(v);
+  std::unordered_set<std::string> input_args;
+  for (auto& kv : map_arg_type) {
+      auto arg_name = std::get<0>(kv.second);
+      input_args.insert(arg_name);
   }
   InputDirectionCollector idc(input_args);
   auto is_arg_written = idc.Analyze(f->body);
@@ -1711,17 +1712,32 @@ void CodeGenSystemC::AddFunction(LoweredFunc f,
   for (size_t i = 0; i < f->args.size(); ++i) {
     Var v = f->args[i];
     string vid = AllocVarID(v.get());
-    if (is_arg_written[vid]) {
-      this->stream << "cynw_p2p < ";
-      PrintType(v.type(), this->stream);
-      this->stream << " >::out " << vid << ";\n";
-    }
-    else {
-      this->stream << "cynw_p2p < ";
+    if (map_arg_type.find(vid) == map_arg_type.end()) {
+      LOG(WARNING) << vid << " type not found\n";
       PrintType(v.type(), this->stream);
-      this->stream << " >::in " << vid << ";\n";
+      this->stream << ' ' << vid;
+    } else {
+      auto arg = map_arg_type[vid];
+      PrintType(std::get<1>(arg), this->stream);
+
+      auto arg_name = std::get<0>(arg);
+      const BufferNode* buf = f->api_args[i].as<BufferNode>();
+      if (v.type().is_handle() && buf) {
+        var_shape_map_[buf->data.get()] = buf->shape;
+      }
+
+      if (is_arg_written[arg_name]) {
+        this->stream << "cynw_p2p < ";
+        PrintType(v.type(), this->stream);
+        this->stream << " >::out " << arg_name << ";\n";
+      }
+      else {
+        this->stream << "cynw_p2p < ";
+        PrintType(v.type(), this->stream);
+        this->stream << " >::in " << arg_name << ";\n";
+      }
+      vid_array.push_back(arg_name);
     }
-    vid_array.push_back(vid);
   }
 
   this->stream << "\nSC_CTOR( " << f->name << " )\n";